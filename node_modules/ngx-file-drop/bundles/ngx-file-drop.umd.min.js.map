{"version":3,"file":"ngx-file-drop.umd.min.js","sources":["../../../node_modules/src/util/tryCatch.ts","../../../node_modules/src/Subscription.ts","../../../node_modules/src/util/pipe.ts","../../../node_modules/src/util/isArray.ts","../../../node_modules/src/util/isNumeric.ts","../../../node_modules/src/util/root.ts","../../../node_modules/src/util/isFunction.ts","../../../node_modules/src/util/isObject.ts","../../../node_modules/src/util/errorObject.ts","../../../node_modules/src/util/UnsubscriptionError.ts","../../../node_modules/src/Observer.ts","../../../node_modules/src/symbol/rxSubscriber.ts","../../../node_modules/src/Subscriber.ts","../../../node_modules/src/util/toSubscriber.ts","../../../node_modules/src/symbol/observable.ts","../../../node_modules/src/util/noop.ts","../../../node_modules/src/Observable.ts","../../../node_modules/src/scheduler/Action.ts","../../../node_modules/src/scheduler/AsyncAction.ts","../../../node_modules/src/Scheduler.ts","../../../node_modules/src/scheduler/async.ts","../../../node_modules/src/scheduler/AsyncScheduler.ts","../../../node_modules/src/util/isScheduler.ts","../../../node_modules/src/util/isDate.ts","../../../node_modules/src/observable/TimerObservable.ts","~/ngx-file-drop/src/lib/ngx-drop/upload-file.model.ts","~/ngx-file-drop/src/lib/ngx-drop/upload-event.model.ts","~/ngx-file-drop/src/lib/ngx-drop/file-drop.component.ts","~/ngx-file-drop/src/lib/ngx-drop/file-drop.module.ts"],"sourcesContent":["import { errorObject } from './errorObject';\n\nlet tryCatchTarget: Function;\n\nfunction tryCatcher(this: any): any {\n  try {\n    return tryCatchTarget.apply(this, arguments);\n  } catch (e) {\n    errorObject.e = e;\n    return errorObject;\n  }\n}\n\nexport function tryCatch<T extends Function>(fn: T): T {\n  tryCatchTarget = fn;\n  return <any>tryCatcher;\n};\n","import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\n\nexport interface AnonymousSubscription {\n  unsubscribe(): void;\n}\n\nexport type TeardownLogic = AnonymousSubscription | Function | void;\n\nexport interface ISubscription extends AnonymousSubscription {\n  unsubscribe(): void;\n  readonly closed: boolean;\n}\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements ISubscription {\n  public static EMPTY: Subscription = (function(empty: any){\n    empty.closed = true;\n    return empty;\n  }(new Subscription()));\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   * @type {boolean}\n   */\n  public closed: boolean = false;\n\n  protected _parent: Subscription = null;\n  protected _parents: Subscription[] = null;\n  private _subscriptions: ISubscription[] = null;\n\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  constructor(unsubscribe?: () => void) {\n    if (unsubscribe) {\n      (<any> this)._unsubscribe = unsubscribe;\n    }\n  }\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let hasErrors = false;\n    let errors: any[];\n\n    if (this.closed) {\n      return;\n    }\n\n    let { _parent, _parents, _unsubscribe, _subscriptions } = (<any> this);\n\n    this.closed = true;\n    this._parent = null;\n    this._parents = null;\n    // null out _subscriptions first so any child subscriptions that attempt\n    // to remove themselves from this subscription will noop\n    this._subscriptions = null;\n\n    let index = -1;\n    let len = _parents ? _parents.length : 0;\n\n    // if this._parent is null, then so is this._parents, and we\n    // don't have to remove ourselves from any parent subscriptions.\n    while (_parent) {\n      _parent.remove(this);\n      // if this._parents is null or index >= len,\n      // then _parent is set to null, and the loop exits\n      _parent = ++index < len && _parents[index] || null;\n    }\n\n    if (isFunction(_unsubscribe)) {\n      let trial = tryCatch(_unsubscribe).call(this);\n      if (trial === errorObject) {\n        hasErrors = true;\n        errors = errors || (\n          errorObject.e instanceof UnsubscriptionError ?\n            flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]\n        );\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n\n      index = -1;\n      len = _subscriptions.length;\n\n      while (++index < len) {\n        const sub = _subscriptions[index];\n        if (isObject(sub)) {\n          let trial = tryCatch(sub.unsubscribe).call(sub);\n          if (trial === errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            let err = errorObject.e;\n            if (err instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new UnsubscriptionError(errors);\n    }\n  }\n\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n  add(teardown: TeardownLogic): Subscription {\n    if (!teardown || (teardown === Subscription.EMPTY)) {\n      return Subscription.EMPTY;\n    }\n\n    if (teardown === this) {\n      return this;\n    }\n\n    let subscription = (<Subscription> teardown);\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(<(() => void) > teardown);\n      case 'object':\n        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n          const tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n        break;\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n\n    const subscriptions = this._subscriptions || (this._subscriptions = []);\n\n    subscriptions.push(subscription);\n    subscription._addParent(this);\n\n    return subscription;\n  }\n\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n  remove(subscription: Subscription): void {\n    const subscriptions = this._subscriptions;\n    if (subscriptions) {\n      const subscriptionIndex = subscriptions.indexOf(subscription);\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  }\n\n  private _addParent(parent: Subscription) {\n    let { _parent, _parents } = this;\n    if (!_parent || _parent === parent) {\n      // If we don't have a parent, or the new parent is the same as the\n      // current parent, then set this._parent to the new parent.\n      this._parent = parent;\n    } else if (!_parents) {\n      // If there's already one parent, but not multiple, allocate an Array to\n      // store the rest of the parent Subscriptions.\n      this._parents = [parent];\n    } else if (_parents.indexOf(parent) === -1) {\n      // Only add the new parent to the _parents list if it's not already there.\n      _parents.push(parent);\n    }\n  }\n}\n\nfunction flattenUnsubscriptionErrors(errors: any[]) {\n return errors.reduce((errs, err) => errs.concat((err instanceof UnsubscriptionError) ? err.errors : err), []);\n}\n","import { noop } from './noop';\nimport { UnaryFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function pipe<T>(): UnaryFunction<T, T>;\nexport function pipe<T, A>(op1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>, op9: UnaryFunction<H, I>): UnaryFunction<T, I>;\n/* tslint:enable:max-line-length */\n\nexport function pipe<T, R>(...fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  return pipeFromArray(fns);\n}\n\n/* @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (!fns) {\n    return noop as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input);\n  };\n}\n","export const isArray = Array.isArray || (<T>(x: any): x is T[] => x && typeof x.length === 'number');\n","import { isArray } from '../util/isArray';\n\nexport function isNumeric(val: any): val is number {\n  // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n  // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n  // subtraction forces infinities to NaN\n  // adding 1 corrects loss of precision from parseFloat (#15100)\n  return !isArray(val) && (val - parseFloat(val) + 1) >= 0;\n};\n","declare let global: any;\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\ndeclare var WorkerGlobalScope: any;\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\n\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\nconst _root: any = __window || __global || __self;\n\n// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.\n// This is needed when used with angular/tsickle which inserts a goog.module statement.\n// Wrap in IIFE\n(function () {\n  if (!_root) {\n    throw new Error('RxJS could not find any global context (window, self, global)');\n  }\n})();\n\nexport { _root as root };","export function isFunction(x: any): x is Function {\n  return typeof x === 'function';\n}\n","export function isObject(x: any): x is Object {\n  return x != null && typeof x === 'object';\n}\n","// typeof any so that it we don't have to cast when comparing a result to the error object\nexport const errorObject: any = { e: {} };","/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport class UnsubscriptionError extends Error {\n  constructor(public errors: any[]) {\n    super();\n    const err: any = Error.call(this, errors ?\n      `${errors.length} errors occurred during unsubscription:\n  ${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '');\n    (<any> this).name = err.name = 'UnsubscriptionError';\n    (<any> this).stack = err.stack;\n    (<any> this).message = err.message;\n  }\n}\n","export interface NextObserver<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error?: (err: any) => void;\n  complete?: () => void;\n}\n\nexport interface ErrorObserver<T> {\n  closed?: boolean;\n  next?: (value: T) => void;\n  error: (err: any) => void;\n  complete?: () => void;\n}\n\nexport interface CompletionObserver<T> {\n  closed?: boolean;\n  next?: (value: T) => void;\n  error?: (err: any) => void;\n  complete: () => void;\n}\n\nexport type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;\n\nexport interface Observer<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\nexport const empty: Observer<any> = {\n  closed: true,\n  next(value: any): void { /* noop */},\n  error(err: any): void { throw err; },\n  complete(): void { /*noop*/ }\n};\n","import { root } from '../util/root';\n\nconst Symbol: any = root.Symbol;\n\nexport const rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n  Symbol.for('rxSubscriber') : '@@rxSubscriber';\n\n/**\n * @deprecated use rxSubscriber instead\n */\nexport const $$rxSubscriber = rxSubscriber;\n","import { isFunction } from './util/isFunction';\nimport { Observer, PartialObserver } from './Observer';\nimport { Subscription } from './Subscription';\nimport { empty as emptyObserver } from './Observer';\nimport { rxSubscriber as rxSubscriberSymbol } from './symbol/rxSubscriber';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  [rxSubscriberSymbol]() { return this; }\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  public syncErrorValue: any = null;\n  public syncErrorThrown: boolean = false;\n  public syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: PartialObserver<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = emptyObserver;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = emptyObserver;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          if (destinationOrNext instanceof Subscriber) {\n            this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\n            this.destination = (<Subscriber<any>> destinationOrNext);\n            (<any> this.destination).add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached {@link Error}. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n\n  protected _unsubscribeAndRecycle(): Subscriber<T> {\n    const { _parent, _parents } = this;\n    this._parent = null;\n    this._parents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parent = _parent;\n    this._parents = _parents;\n    return this;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(private _parentSubscriber: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    let next: ((value: T) => void);\n    let context: any = this;\n\n    if (isFunction(observerOrNext)) {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (observerOrNext !== emptyObserver) {\n        context = Object.create(observerOrNext);\n        if (isFunction(context.unsubscribe)) {\n          this.add(<() => void> context.unsubscribe.bind(context));\n        }\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parentSubscriber } = this;\n      if (!_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._error) {\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n        throw err;\n      } else {\n        _parentSubscriber.syncErrorValue = err;\n        _parentSubscriber.syncErrorThrown = true;\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._complete) {\n        const wrappedComplete = () => this._complete.call(this._context);\n\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      throw err;\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      parent.syncErrorValue = err;\n      parent.syncErrorThrown = true;\n      return true;\n    }\n    return false;\n  }\n\n  protected _unsubscribe(): void {\n    const { _parentSubscriber } = this;\n    this._context = null;\n    this._parentSubscriber = null;\n    _parentSubscriber.unsubscribe();\n  }\n}\n","import { Subscriber } from '../Subscriber';\nimport { rxSubscriber as rxSubscriberSymbol } from '../symbol/rxSubscriber';\nimport { PartialObserver, empty as emptyObserver } from '../Observer';\n\nexport function toSubscriber<T>(\n  nextOrObserver?: PartialObserver<T> | ((value: T) => void),\n  error?: (error: any) => void,\n  complete?: () => void): Subscriber<T> {\n\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return (<Subscriber<T>> nextOrObserver);\n    }\n\n    if (nextOrObserver[rxSubscriberSymbol]) {\n      return nextOrObserver[rxSubscriberSymbol]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(emptyObserver);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n","import { root } from '../util/root';\n\nexport function getSymbolObservable(context: any) {\n  let $$observable: any;\n  let Symbol = context.Symbol;\n\n  if (typeof Symbol === 'function') {\n    if (Symbol.observable) {\n      $$observable = Symbol.observable;\n    } else {\n        $$observable = Symbol('observable');\n        Symbol.observable = $$observable;\n    }\n  } else {\n    $$observable = '@@observable';\n  }\n\n  return $$observable;\n}\n\nexport const observable = getSymbolObservable(root);\n\n/**\n * @deprecated use observable instead\n */\nexport const $$observable = observable;\n","/* tslint:disable:no-empty */\nexport function noop() { }\n","import { PartialObserver } from './Observer';\nimport { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, AnonymousSubscription, TeardownLogic } from './Subscription';\nimport { root } from './util/root';\nimport { toSubscriber } from './util/toSubscriber';\nimport { IfObservable } from './observable/IfObservable';\nimport { ErrorObservable } from './observable/ErrorObservable';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { OperatorFunction } from './interfaces';\nimport { pipeFromArray } from './util/pipe';\n\nexport interface Subscribable<T> {\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): AnonymousSubscription;\n}\n\nexport type SubscribableOrPromise<T> = Subscribable<T> | PromiseLike<T>;\nexport type ObservableInput<T> = SubscribableOrPromise<T> | ArrayLike<T>;\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n\n  public _isScalar: boolean = false;\n\n  protected source: Observable<any>;\n  protected operator: Operator<any, T>;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new cold Observable by calling the Observable constructor\n   * @static true\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new cold observable\n   */\n  static create: Function = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  }\n\n  /**\n   * Creates a new Observable, with this Observable as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param {Operator} operator the operator defining the operation to take on the observable\n   * @return {Observable} a new observable with the Operator applied\n   */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observer?: PartialObserver<T>): Subscription;\n  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to a {@link create} static factory, but most of the time it is\n   * a library implementation, which defines what and when will be emitted by an Observable. This means that calling\n   * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will\n   * be left uncaught.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent\n   * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,\n   * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n   *\n   * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.\n   *\n   * @example <caption>Subscribe with an Observer</caption>\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() { // We actually could just remove this method,\n   *   },        // since we do not really care about errors right now.\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   * .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   *\n   *\n   * @example <caption>Subscribe with functions</caption>\n   * let sum = 0;\n   *\n   * Rx.Observable.of(1, 2, 3)\n   * .subscribe(\n   *   function(value) {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   function() {\n   *     console.log('Sum equals: ' + sum);\n   *   }\n   * );\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   *\n   *\n   * @example <caption>Cancel a subscription</caption>\n   * const subscription = Rx.Observable.interval(1000).subscribe(\n   *   num => console.log(num),\n   *   undefined,\n   *   () => console.log('completed!') // Will not be called, even\n   * );                                // when cancelling subscription\n   *\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // \"unsubscribed!\" after 2.5s\n   *\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   *  Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   *  the error will be thrown as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {ISubscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): Subscription {\n\n    const { operator } = this;\n    const sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      operator.call(sink, this.source);\n    } else {\n      sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));\n    }\n\n    if (sink.syncErrorThrowable) {\n      sink.syncErrorThrowable = false;\n      if (sink.syncErrorThrown) {\n        throw sink.syncErrorValue;\n      }\n    }\n\n    return sink;\n  }\n\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      sink.syncErrorThrown = true;\n      sink.syncErrorValue = err;\n      sink.error(err);\n    }\n  }\n\n  /**\n   * @method forEach\n   * @param {Function} next a handler for each value emitted by the observable\n   * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n   * @return {Promise} a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void, PromiseCtor?: typeof Promise): Promise<void> {\n    if (!PromiseCtor) {\n      if (root.Rx && root.Rx.config && root.Rx.config.Promise) {\n        PromiseCtor = root.Rx.config.Promise;\n      } else if (root.Promise) {\n        PromiseCtor = root.Promise;\n      }\n    }\n\n    if (!PromiseCtor) {\n      throw new Error('no Promise impl found');\n    }\n\n    return new PromiseCtor<void>((resolve, reject) => {\n      // Must be declared in a separate statement to avoid a RefernceError when\n      // accessing subscription below in the closure due to Temporal Dead Zone.\n      let subscription: Subscription;\n      subscription = this.subscribe((value) => {\n        if (subscription) {\n          // if there is a subscription, then we can surmise\n          // the next handling is asynchronous. Any errors thrown\n          // need to be rejected explicitly and unsubscribe must be\n          // called manually\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscription.unsubscribe();\n          }\n        } else {\n          // if there is NO subscription, then we're getting a nexted\n          // value synchronously during subscription. We can just call it.\n          // If it errors, Observable's `subscribe` will ensure the\n          // unsubscription logic is called, then synchronously rethrow the error.\n          // After that, Promise will trap the error and send it\n          // down the rejection path.\n          next(value);\n        }\n      }, reject, resolve);\n    });\n  }\n\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source.subscribe(subscriber);\n  }\n\n  // `if` and `throw` are special snow flakes, the compiler sees them as reserved words\n  static if: typeof IfObservable.create;\n  static throw: typeof ErrorObservable.create;\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>\n  pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>\n  pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>\n  pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>\n  pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>\n  pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>\n  pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * @example\n   *\n   * import { map, filter, scan } from 'rxjs/operators';\n   *\n   * Rx.Observable.interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x))\n   */\n  pipe<R>(...operations: OperatorFunction<T, R>[]): Observable<R> {\n    if (operations.length === 0) {\n      return this as any;\n    }\n\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  toPromise<T>(this: Observable<T>): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: typeof Promise): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: PromiseConstructorLike): Promise<T>;\n  /* tslint:enable:max-line-length */\n\n  toPromise(PromiseCtor?: PromiseConstructorLike) {\n    if (!PromiseCtor) {\n      if (root.Rx && root.Rx.config && root.Rx.config.Promise) {\n        PromiseCtor = root.Rx.config.Promise;\n      } else if (root.Promise) {\n        PromiseCtor = root.Promise;\n      }\n    }\n\n    if (!PromiseCtor) {\n      throw new Error('no Promise impl found');\n    }\n\n    return new PromiseCtor((resolve, reject) => {\n      let value: any;\n      this.subscribe((x: T) => value = x, (err: any) => reject(err), () => resolve(value));\n    }) as Promise<T>;\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\n\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: Action<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent Scheduler for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler.\n   * @return {void}\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n","import { root } from '../util/root';\nimport { Action } from './Action';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AsyncAction<T> extends Action<T> {\n\n  public id: any;\n  public state: T;\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler,\n              protected work: (this: AsyncAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n\n    if (this.closed) {\n      return this;\n     }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay: number = 0): any {\n    return root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay: number = 0): any {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    return root.clearInterval(id) && undefined || undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any = undefined;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  protected _unsubscribe() {\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n    const actions = scheduler.actions;\n    const index = actions.indexOf(this);\n\n    this.work  = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  }\n}\n","import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\n\nexport interface IScheduler {\n  now(): number;\n  schedule<T>(work: (this: Action<T>, state?: T) => void, delay?: number, state?: T): Subscription;\n}\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n */\nexport class Scheduler implements IScheduler {\n\n  public static now: () => number = Date.now ? Date.now : () => +new Date();\n\n  constructor(private SchedulerAction: typeof Action,\n              now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return {number} A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param {function(state: ?T): ?Subscription} work A function representing a\n   * task, or some unit of work to be executed by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler itself.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @return {Subscription} A subscription in order to be able to unsubscribe\n   * the scheduled work.\n   */\n  public schedule<T>(work: (this: Action<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.SchedulerAction<T>(this, work).schedule(state, delay);\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asap} scheduler.\n *\n * @example <caption>Use async scheduler to delay task</caption>\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n *\n *\n * @example <caption>Use async scheduler to repeat task in intervals</caption>\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\n\nexport const async = new AsyncScheduler(AsyncAction);\n","import { Scheduler } from '../Scheduler';\nimport { AsyncAction } from './AsyncAction';\n\nexport class AsyncScheduler extends Scheduler {\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   */\n  public active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   */\n  public scheduled: any = undefined;\n\n  public flush(action: AsyncAction<any>): void {\n\n    const {actions} = this;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift()); // exhaust the scheduler queue\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { Scheduler } from '../Scheduler';\nexport function isScheduler(value: any): value is Scheduler {\n  return value && typeof (<any>value).schedule === 'function';\n}\n","export function isDate(value: any): value is Date {\n  return value instanceof Date && !isNaN(+value);\n}\n","import { isNumeric } from '../util/isNumeric';\nimport { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { async } from '../scheduler/async';\nimport { isScheduler } from '../util/isScheduler';\nimport { isDate } from '../util/isDate';\nimport { TeardownLogic } from '../Subscription';\nimport { Subscriber } from '../Subscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class TimerObservable extends Observable<number> {\n\n  /**\n   * Creates an Observable that starts emitting after an `initialDelay` and\n   * emits ever increasing numbers after each `period` of time thereafter.\n   *\n   * <span class=\"informal\">Its like {@link interval}, but you can specify when\n   * should the emissions start.</span>\n   *\n   * <img src=\"./img/timer.png\" width=\"100%\">\n   *\n   * `timer` returns an Observable that emits an infinite sequence of ascending\n   * integers, with a constant interval of time, `period` of your choosing\n   * between those emissions. The first emission happens after the specified\n   * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n   * operator uses the `async` IScheduler to provide a notion of time, but you\n   * may pass any IScheduler to it. If `period` is not specified, the output\n   * Observable emits only one value, `0`. Otherwise, it emits an infinite\n   * sequence.\n   *\n   * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n   * var numbers = Rx.Observable.timer(3000, 1000);\n   * numbers.subscribe(x => console.log(x));\n   *\n   * @example <caption>Emits one number after five seconds</caption>\n   * var numbers = Rx.Observable.timer(5000);\n   * numbers.subscribe(x => console.log(x));\n   *\n   * @see {@link interval}\n   * @see {@link delay}\n   *\n   * @param {number|Date} initialDelay The initial delay time to wait before\n   * emitting the first value of `0`.\n   * @param {number} [period] The period of time between emissions of the\n   * subsequent numbers.\n   * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n   * the emission of values, and providing a notion of \"time\".\n   * @return {Observable} An Observable that emits a `0` after the\n   * `initialDelay` and ever increasing numbers after each `period` of time\n   * thereafter.\n   * @static true\n   * @name timer\n   * @owner Observable\n   */\n  static create(initialDelay: number | Date = 0,\n                period?: number | IScheduler,\n                scheduler?: IScheduler): Observable<number> {\n    return new TimerObservable(initialDelay, period, scheduler);\n  }\n\n  static dispatch(state: any) {\n\n    const { index, period, subscriber } = state;\n    const action = (<any> this);\n\n    subscriber.next(index);\n\n    if (subscriber.closed) {\n      return;\n    } else if (period === -1) {\n      return subscriber.complete();\n    }\n\n    state.index = index + 1;\n    action.schedule(state, period);\n  }\n\n  private period: number = -1;\n  private dueTime: number = 0;\n  private scheduler: IScheduler;\n\n  constructor(dueTime: number | Date = 0,\n              period?: number | IScheduler,\n              scheduler?: IScheduler) {\n    super();\n\n    if (isNumeric(period)) {\n      this.period = Number(period) < 1 && 1 || Number(period);\n    } else if (isScheduler(period)) {\n      scheduler = <IScheduler> period;\n    }\n\n    if (!isScheduler(scheduler)) {\n      scheduler = async;\n    }\n\n    this.scheduler = scheduler;\n    this.dueTime = isDate(dueTime) ?\n      (+dueTime - this.scheduler.now()) :\n      (<number> dueTime);\n  }\n\n  protected _subscribe(subscriber: Subscriber<number>): TeardownLogic {\n    const index = 0;\n    const { period, dueTime, scheduler } = this;\n\n    return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n      index, period, subscriber\n    });\n  }\n}\n","\nexport class UploadFile {\n/**\n * @param {?} relativePath\n * @param {?} fileEntry\n */\nconstructor(\npublic relativePath: string,\npublic fileEntry: any) {\n    }\n}\n\nfunction UploadFile_tsickle_Closure_declarations() {\n/** @type {?} */\nUploadFile.prototype.relativePath;\n/** @type {?} */\nUploadFile.prototype.fileEntry;\n}\n\n","import { UploadFile } from './upload-file.model';\nexport class UploadEvent {\n/**\n * @param {?} files\n */\nconstructor(\npublic files: UploadFile[]) {\n    }\n}\n\nfunction UploadEvent_tsickle_Closure_declarations() {\n/** @type {?} */\nUploadEvent.prototype.files;\n}\n\n","import { Component, Input, Output, EventEmitter, NgZone, OnDestroy } from '@angular/core';\nimport { Subscription } from 'rxjs/Rx';\nimport { TimerObservable } from 'rxjs/observable/TimerObservable';\n\nimport { UploadFile } from './upload-file.model';\nimport { UploadEvent } from './upload-event.model';\nexport class FileComponent implements OnDestroy {\n\n  \n  headertext: string = '';\n  \n  customstyle: string = null;\npublic onFileDrop: EventEmitter<UploadEvent> = new EventEmitter<UploadEvent>();\npublic onFileOver: EventEmitter<any> = new EventEmitter<any>();\npublic onFileLeave: EventEmitter<any> = new EventEmitter<any>();\n\n  stack = [];\n  files: UploadFile[] = [];\n  subscription: Subscription;\n  dragoverflag: boolean = false;\n/**\n * @param {?} zone\n */\nconstructor(private zone: NgZone) {\n    if (!this.customstyle) {\n      this.customstyle = 'drop-zone';\n    }\n  }\n/**\n * @param {?} event\n * @return {?}\n */\npublic onDragOver(event: Event): void {\n    if (!this.dragoverflag) {\n      this.dragoverflag = true;\n      this.onFileOver.emit(event);\n    }\n    this.preventAndStop(event);\n  }\n/**\n * @param {?} event\n * @return {?}\n */\npublic onDragLeave(event: Event): void {\n    if (this.dragoverflag) {\n      this.dragoverflag = false;\n      this.onFileLeave.emit(event);\n    }\n    this.preventAndStop(event);\n  }\n/**\n * @param {?} event\n * @return {?}\n */\ndropFiles(event: any) {\n    this.dragoverflag = false;\n    event.dataTransfer.dropEffect = 'copy';\n    let /** @type {?} */ length;\n    if (event.dataTransfer.items) {\n      length = event.dataTransfer.items.length;\n    } else {\n      length = event.dataTransfer.files.length;\n    }\n\n    for (let /** @type {?} */ i = 0; i < length; i++) {\n      let /** @type {?} */ entry;\n      if (event.dataTransfer.items) {\n        if (event.dataTransfer.items[i].webkitGetAsEntry) {\n          entry = event.dataTransfer.items[i].webkitGetAsEntry();\n        }\n      } else {\n        if (event.dataTransfer.files[i].webkitGetAsEntry) {\n          entry = event.dataTransfer.files[i].webkitGetAsEntry();\n        }\n      }\n      if (!entry) {\n        const /** @type {?} */ file = event.dataTransfer.files[i];\n\n        if (file) {\n          entry = {\n            name: file.name,\n            resultFile: file,\n            file: function(fileProcess) {\n                  fileProcess(this.resultFile);\n            }\n          }\n          const /** @type {?} */ /** @type {?} */ toUpload = new UploadFile(entry.name, entry);\n          this.addToQueue(toUpload);\n        }\n      } else {\n        if (entry.isFile) {\n            const /** @type {?} */ toUpload: UploadFile = new UploadFile(entry.name, entry);\n            this.addToQueue(toUpload);\n        } else if (entry.isDirectory) {\n            this.traverseFileTree(entry, entry.name);\n        }\n      }\n    }\n\n    this.preventAndStop(event);\n\n    const /** @type {?} */ timer = TimerObservable.create(200, 200);\n    this.subscription = timer.subscribe(t => {\n      if (this.stack.length === 0) {\n        this.onFileDrop.emit(new UploadEvent(this.files));\n        this.files = [];\n        this.subscription.unsubscribe();\n      }\n    });\n\n  }\n/**\n * @param {?} item\n * @param {?} path\n * @return {?}\n */\nprivate traverseFileTree(item, path) {\n\n    if (item.isFile) {\n      const /** @type {?} */ toUpload: UploadFile = new UploadFile(path, item);\n      this.files.push(toUpload);\n      this.zone.run(() => {\n        this.popToStack();\n      });\n    } else {\n      this.pushToStack(path);\n      path = path + '/';\n      const /** @type {?} */ dirReader = item.createReader();\n      let /** @type {?} */ entries = [];\n      const /** @type {?} */ thisObj = this;\n\n      const /** @type {?} */ readEntries = function () {\n        dirReader.readEntries(function (res) {\n          if (!res.length) {\n            // add empty folders\n            if (entries.length === 0) {\n              const /** @type {?} */ toUpload: UploadFile = new UploadFile(path, item);\n              thisObj.zone.run(() => {\n                thisObj.addToQueue(toUpload);\n              });\n            } else {\n              for (let /** @type {?} */ i = 0; i < entries.length; i++) {\n                thisObj.zone.run(() => {\n                  thisObj.traverseFileTree(entries[i], path + entries[i].name);\n                });\n              }\n            }\n            thisObj.zone.run(() => {\n              thisObj.popToStack();\n            });\n          } else {\n            // continue with the reading\n            entries = entries.concat(res);\n            readEntries();\n          }\n        });\n      };\n\n      readEntries();\n    }\n  }\n/**\n * @param {?} item\n * @return {?}\n */\nprivate addToQueue(item) {\n    this.files.push(item);\n  }\n/**\n * @param {?} str\n * @return {?}\n */\npushToStack(str) {\n    this.stack.push(str);\n  }\n/**\n * @return {?}\n */\npopToStack() {\n    const /** @type {?} */ value = this.stack.pop();\n  }\n/**\n * @return {?}\n */\nprivate clearQueue() {\n    this.files = [];\n  }\n/**\n * @param {?} event\n * @return {?}\n */\nprivate preventAndStop(event) {\n    event.stopPropagation();\n    event.preventDefault();\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Component, args: [{\n  selector: 'file-drop',\n  template: `\n    <div id=\"dropZone\"  [className]=\"customstyle\" [class.over]=\"dragoverflag\"\n        (drop)=\"dropFiles($event)\"\n        (dragover)=\"onDragOver($event)\" (dragleave)=\"onDragLeave($event)\">\n        <div class=\"content\">\n            <ng-content></ng-content>\n            {{headertext}}\n        </div>\n    </div>\n  `,\n  styles: [`\n    .drop-zone {\n      margin: auto;\n      height: 100px;\n      border: 2px dotted #0782d0;\n      border-radius: 30px; }\n\n    .content {\n      color: #0782d0;\n      height: 100px;\n      display: -webkit-box;\n      display: -ms-flexbox;\n      display: flex;\n      -webkit-box-pack: center;\n          -ms-flex-pack: center;\n              justify-content: center;\n      -webkit-box-align: center;\n          -ms-flex-align: center;\n              align-items: center; }\n\n    .over {\n      background-color: rgba(147, 147, 147, 0.5); }\n  `]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: NgZone, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'headertext': [{ type: Input },],\n'customstyle': [{ type: Input },],\n'onFileDrop': [{ type: Output },],\n'onFileOver': [{ type: Output },],\n'onFileLeave': [{ type: Output },],\n};\n}\n\nfunction FileComponent_tsickle_Closure_declarations() {\n/** @type {?} */\nFileComponent.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nFileComponent.ctorParameters;\n/** @type {?} */\nFileComponent.propDecorators;\n/** @type {?} */\nFileComponent.prototype.headertext;\n/** @type {?} */\nFileComponent.prototype.customstyle;\n/** @type {?} */\nFileComponent.prototype.onFileDrop;\n/** @type {?} */\nFileComponent.prototype.onFileOver;\n/** @type {?} */\nFileComponent.prototype.onFileLeave;\n/** @type {?} */\nFileComponent.prototype.stack;\n/** @type {?} */\nFileComponent.prototype.files;\n/** @type {?} */\nFileComponent.prototype.subscription;\n/** @type {?} */\nFileComponent.prototype.dragoverflag;\n/** @type {?} */\nFileComponent.prototype.zone;\n}\n\n\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule } from '@angular/core';\nimport {FileComponent} from './file-drop.component';\nexport class FileDropModule {static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  declarations: [\n    FileComponent,\n  ],\n  exports: [FileComponent],\n  imports: [],\n  providers: [],\n  bootstrap: [FileComponent],\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction FileDropModule_tsickle_Closure_declarations() {\n/** @type {?} */\nFileDropModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nFileDropModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":["tryCatcher","tryCatchTarget","apply","this","arguments","e","errorObject_1","errorObject","flattenUnsubscriptionErrors","errors","reduce","errs","err","concat","UnsubscriptionError_1","UnsubscriptionError","pipeFromArray","fns","length","input","prev","fn","noop_1","noop","Array","isArray","x","val","isArray_1","parseFloat","__window","window","__self","self","WorkerGlobalScope","_root","global","root_1","Error","_super","call","map","i","toString","join","name","stack","message","__extends","Subscription","unsubscribe","closed","_parent","_parents","_subscriptions","_unsubscribe","prototype","hasErrors","index","len","remove","isFunction_1","isFunction","trial","tryCatch_1","tryCatch","sub","isObject_1","isObject","push","add","teardown","EMPTY","subscription","_addParent","tmp","subscriptions","subscriptionIndex","indexOf","splice","parent","empty","next","value","error","complete","Symbol","root","exports","rxSubscriber","for","$$rxSubscriber","Subscriber","destinationOrNext","syncErrorValue","syncErrorThrown","syncErrorThrowable","isStopped","destination","Observer_1","SafeSubscriber","rxSubscriber_1","create","subscriber","_next","_error","_complete","_unsubscribeAndRecycle","Subscription_1","Subscriber_2","_parentSubscriber","observerOrNext","context","Object","bind","_context","__tryOrSetError","__tryOrUnsub","_this","wrappedComplete","nextOrObserver","Subscriber_1","getSymbolObservable","$$observable","observable","_i","Observable","subscribe","_isScalar","_subscribe","lift","operator","source","sink","toSubscriber_1","toSubscriber","_trySubscribe","forEach","PromiseCtor","Rx","config","Promise","resolve","reject","observable_1","pipe","operations","pipe_1","toPromise","Action","scheduler","work","schedule","state","delay","AsyncAction","pending","id","recycleAsyncId","requestAsyncId","setInterval","flush","clearInterval","undefined","execute","_execute","errored","errorValue","actions","Action_1","Scheduler","SchedulerAction","now","Date","AsyncScheduler","active","scheduled","action","shift","Scheduler_1","AsyncAction_1","isNaN","TimerObservable_2","TimerObservable","dueTime","period","isNumeric_1","isNumeric","Number","isScheduler_1","isScheduler","async_1","async","isDate_1","isDate","initialDelay","dispatch","Observable_1","UploadFile","relativePath","fileEntry","UploadEvent","files","FileComponent","zone","headertext","customstyle","onFileDrop","EventEmitter","onFileOver","onFileLeave","dragoverflag","onDragOver","event","emit","preventAndStop","onDragLeave","dropFiles","dataTransfer","dropEffect","items","entry","webkitGetAsEntry","isFile","toUpload","addToQueue","isDirectory","traverseFileTree","file","resultFile","fileProcess","timer","t","item","path","run","popToStack","pushToStack","dirReader_1","createReader","entries_1","thisObj_1","readEntries_1","readEntries","res","toUpload_1","_loop_1","str","pop","clearQueue","stopPropagation","preventDefault","ngOnDestroy","decorators","type","Component","args","selector","template","styles","ctorParameters","NgZone","propDecorators","Input","Output","FileDropModule","NgModule","declarations","imports","providers","bootstrap"],"mappings":"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"}
